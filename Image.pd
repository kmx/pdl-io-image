use strict;
use warnings;
our $VERSION = '0.001';

pp_setversion($VERSION);

############################################################### C part
pp_addhdr(<<'ENDHDR');

#include <FreeImage.h>

typedef struct img_struct {
  FIBITMAP *dib;
  int id;
} *PDL__IO__Image;

FREE_IMAGE_FORMAT _sv2fif(SV *f)
{
  int i;
  if (f == NULL) return FIF_UNKNOWN;
  if (!SvOK(f)) return FIF_UNKNOWN;
  if (SvIOK(f)) {
    i = SvIV(f);
    if (FreeImage_IsPluginEnabled((FREE_IMAGE_FORMAT)i)) return (FREE_IMAGE_FORMAT)i;
  }
  if (SvPOK(f)) {
    return FreeImage_GetFIFFromFormat(SvPV_nolen(f));
  }
  return FIF_UNKNOWN;
}

FREE_IMAGE_TYPE _sv2fit(SV *f)
{
  int i;
  if (f == NULL) return FIT_UNKNOWN;
  if (!SvOK(f)) return FIT_UNKNOWN;
  if (SvIOK(f)) {
    i = SvIV(f);
    if ( i == FIT_BITMAP  ||
         i == FIT_UINT16  ||
         i == FIT_INT16   ||
         i == FIT_UINT32  ||
         i == FIT_INT32   ||
         i == FIT_FLOAT   ||
         i == FIT_DOUBLE  ||
         i == FIT_COMPLEX ||
         i == FIT_RGB16   ||
         i == FIT_RGBA16  ||
         i == FIT_RGBF    ||
         i == FIT_RGBAF ) return (FREE_IMAGE_TYPE)i;
  }
  if (SvPOK(f)) {
    char *name = SvPV_nolen(f);
    if (memEQ(name, "BITMAP",  6)) return FIT_BITMAP;
    if (memEQ(name, "UINT16",  6)) return FIT_UINT16;
    if (memEQ(name, "INT16",   5)) return FIT_INT16;
    if (memEQ(name, "UINT32",  6)) return FIT_UINT32;
    if (memEQ(name, "INT32",   5)) return FIT_INT32;
    if (memEQ(name, "FLOAT",   5)) return FIT_FLOAT;
    if (memEQ(name, "DOUBLE",  6)) return FIT_DOUBLE;
    if (memEQ(name, "COMPLEX", 7)) return FIT_COMPLEX;
    if (memEQ(name, "RGB16",   5)) return FIT_RGB16;
    if (memEQ(name, "RGBA16",  6)) return FIT_RGBA16;
    if (memEQ(name, "RGBF",    4)) return FIT_RGBF;
    if (memEQ(name, "RGBAF",   5)) return FIT_RGBAF;
  }
  return FIT_UNKNOWN;
}

void _pdl2imparams(pdl *pix, pdl *pal, FREE_IMAGE_TYPE *fit, unsigned *width, unsigned *height, int *bpp, int *palsize)
{
  int ty = -1, di = -1;
  PDL_Indx i, n;
  PDL_Byte *bptr = NULL, bmax = 0;
  *fit = FIT_UNKNOWN;
  *bpp = 0;
  *palsize = 0;

  if (pix == NULL) return;
  
  ty = pix->datatype;
  di = pix->ndims;
  
  if (pal != NULL) {
    if ( pal->datatype == PDL_B &&
         pal->ndims == 2 &&
         pal->dims[0] == 3 &&
         pal->dims[1] > 0 &&
         pal->dims[1] <= 256 ) *palsize = pal->dims[1];
    if (*palsize == 0) {
      warn("wrong palette piddle, has to be Byte[3, n] (0 < n <= 256)");
    }
  }
   
  if (di == 2) {
    *width  = pix->dims[0];
    *height = pix->dims[1];
    n = pix->dims[0] * pix->dims[1];
    if (ty == PDL_D ) { *bpp = 64; *fit = FIT_DOUBLE; }
    if (ty == PDL_F ) { *bpp = 32; *fit = FIT_FLOAT;  }
    if (ty == PDL_L ) { *bpp = 32; *fit = FIT_INT32;  }
    if (ty == PDL_LL) { *bpp = 32; *fit = FIT_UINT32; } /* XXX-TODO hack: using INT64 for UINT32 */
    if (ty == PDL_S ) { *bpp = 16; *fit = FIT_INT16;  }
    if (ty == PDL_US) { *bpp = 16; *fit = FIT_UINT16; }
    if (ty == PDL_B ) {
      *fit = FIT_BITMAP;
      /* bpp detection based on max used values */
      for(bptr=(PDL_Byte *)pix->data, i=0; i<n; i++) { if(bptr[i]>bmax) bmax=bptr[i]; }
      if (bmax < 2)          { *bpp = 1; }
      else if (bmax < 16)    { *bpp = 4; }
      else                   { *bpp = 8; }
      /* bpp correction based on pallete size */
      if (*palsize > 16)     { *bpp = 8; }
      else if (*palsize > 2) { *bpp = 4; }
      else if (*palsize > 0) { *bpp = 1; }
    }
  }
  if (di == 3) {
    *width  = pix->dims[0];
    *height = pix->dims[1];
    n = pix->dims[0] * pix->dims[1] * pix->dims[2];
    if (pix->dims[2] == 3) {
      if (ty == PDL_F ) { *bpp = 96; *fit = FIT_RGBF;   }
      if (ty == PDL_US) { *bpp = 48; *fit = FIT_RGB16;  }
      if (ty == PDL_B ) { *bpp = 24; *fit = FIT_BITMAP; } /* XXX-TODO handle 16bpp */
    }
    if (pix->dims[2] == 4) {
      if (ty == PDL_F ) { *bpp =128; *fit = FIT_RGBAF;  }
      if (ty == PDL_US) { *bpp = 64; *fit = FIT_RGBA16; }
      if (ty == PDL_B ) { *bpp = 32; *fit = FIT_BITMAP; } /* XXX-TODO handle 16bpp */
    }
  }

  if (*bpp == 0) {
    warn("wrong pixel pdl, has to be: D|F|L|LL|S|US|B[w,h] F|US|B[w,h,3] F|US|B[w,h,3]");
  }
}


const char* _fit2str(FREE_IMAGE_TYPE f)
{
  if (f == FIT_BITMAP  ) return "BITMAP";
  if (f == FIT_UINT16  ) return "UINT16";
  if (f == FIT_INT16   ) return "INT16";
  if (f == FIT_UINT32  ) return "UINT32";
  if (f == FIT_INT32   ) return "INT32";
  if (f == FIT_FLOAT   ) return "FLOAT";
  if (f == FIT_DOUBLE  ) return "DOUBLE";
  if (f == FIT_COMPLEX ) return "COMPLEX";
  if (f == FIT_RGB16   ) return "RGB16";
  if (f == FIT_RGBA16  ) return "RGBA16";
  if (f == FIT_RGBF    ) return "RGBF";
  if (f == FIT_RGBAF   ) return "RGBAF";
  return "";
}

const char* _fic2str(FREE_IMAGE_COLOR_TYPE c)
{
  if (c == FIC_MINISWHITE) return "MINISWHITE";
  if (c == FIC_MINISBLACK) return "MINISBLACK";
  if (c == FIC_RGB       ) return "RGB";
  if (c == FIC_PALETTE   ) return "PALETTE";
  if (c == FIC_RGBALPHA  ) return "RGBALPHA";
  if (c == FIC_CMYK      ) return "CMYK";
  return "";
}

#include "const-c.inc"

ENDHDR

############################################################# XS part
pp_addxs('', <<'ENDXS' );

BOOT:
        FreeImage_Initialise(FALSE);

INCLUDE: const-xs.inc

PDL::IO::Image
new_from_file(char * class, char * filename, SV *f=NULL, int flags=0, int page=0)
    CODE:
    {
        FIBITMAP *dib = NULL;
        FREE_IMAGE_FORMAT fif = _sv2fif(f);
        if (fif == FIF_UNKNOWN) fif = FreeImage_GetFileType(filename, 0);
        if (fif == FIF_UNKNOWN) fif = FreeImage_GetFIFFromFilename(filename);
        if (fif == FIF_UNKNOWN) croak("FAIL: unknown format '%s'", filename);

        if (page > 0) {
          FIMULTIBITMAP * multi = FreeImage_OpenMultiBitmap(fif, filename, FALSE, TRUE, FALSE, flags);
          if (multi) {
            int count = FreeImage_GetPageCount(multi);
            if (page < count) {
              FIBITMAP *page_dib = FreeImage_LockPage(multi, page);
              dib = FreeImage_Clone(page_dib);
              FreeImage_UnlockPage(multi, page_dib, FALSE);
            }
            else {
              warn("invalid page index '%d' (max=%d)", page, count-1);
            }
            FreeImage_CloseMultiBitmap(multi, 0);
          }
          else {
            warn("cannot open '%s' as multi page image", filename);
          }
        }
        else {
          dib = FreeImage_Load(fif, filename, flags);
        }

        if (dib == NULL) croak("FAIL: cannot load '%s'", filename);
        Newz(0, RETVAL, 1, struct img_struct);
        if (RETVAL == NULL) croak("FAIL: Newz failed");

        RETVAL->dib = dib;
    }
    OUTPUT:
        RETVAL

PDL::IO::Image
new_from_pdl(char * class, pdl * pixels, pdl * palette=NULL)
    CODE:
    {
        FIBITMAP *dib = NULL;
        FREE_IMAGE_TYPE fit = FIT_UNKNOWN;
        int bpp = 0, palsize = 0;
        unsigned w = 0, h = 0, cu = 0, i;
        PDL_Indx x, y, wxh;

        _pdl2imparams(pixels, palette, &fit, &w, &h, &bpp, &palsize);
        if (fit == FIT_UNKNOWN) croak("FAIL: invalid PDL");

        dib = FreeImage_AllocateT(fit, w, h, bpp, 0, 0, 0);
        if (dib == NULL) croak("FAIL: cannot create bitmap from PDL");
        
        wxh = w * h;
        
        switch (fit) {
          case FIT_BITMAP:      /* Standard image: 1-, 4-, 8-, 16-, 24-, 32-bit */
            if (bpp==32) {
              BYTE *pdata = pixels->data;
              for(y = 0; y < h; y++) {
                RGBQUAD *bits = (RGBQUAD*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x].rgbRed      = pdata[(h-1-y)*w + x];
                  bits[x].rgbGreen    = pdata[(h-1-y)*w + x + wxh];
                  bits[x].rgbBlue     = pdata[(h-1-y)*w + x + 2*wxh];
                  bits[x].rgbReserved = pdata[(h-1-y)*w + x + 3*wxh];
                }
              }
            }
            else if (bpp==24) {
              BYTE *pdata = pixels->data;
              for(y = 0; y < h; y++) {
                RGBTRIPLE *bits = (RGBTRIPLE*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x].rgbtRed   = pdata[(h-1-y)*w + x];
                  bits[x].rgbtGreen = pdata[(h-1-y)*w + x + wxh];
                  bits[x].rgbtBlue  = pdata[(h-1-y)*w + x + 2*wxh];
                }
              }
            }
            else if (bpp==8) {
              BYTE *pdata = pixels->data;
              for(y = 0; y < h; y++) {
                BYTE *bits = FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = pdata[(h-1-y)*w + x];
                }
              }
            }
            else if (bpp==4) {
              BYTE *pdata = pixels->data;
              for(y = 0; y < h; y++) {
                BYTE *bits = FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x/2] |= (pdata[(h-1-y)*w + x] & 0x0F) << 4*(1-x%2);
                }
              }
            }
            else if (bpp==1) {
              BYTE *pdata = pixels->data;
              for(y = 0; y < h; y++) {
                BYTE *bits = FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x/8] |= (pdata[(h-1-y)*w + x] & 0x01) << (7-x%8);
                }
              }
            }
            else {
              warn("FAIL: unknown bits per pixel '%d'", bpp);
            }
            break;
          case FIT_UINT16:      /* Array of unsigned short: unsigned 16-bit */
            {
              PDL_Ushort *pdata = (PDL_Ushort *) pixels->data;
              for(y = 0; y < h; y++) {
                PDL_Ushort *bits = (PDL_Ushort*)FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = pdata[(h-1-y)*w + x];
                }
              }
            }
            break;
          case FIT_INT16:       /* Array of short: signed 16-bit */
            {
              PDL_Short *pdata = (PDL_Short *) pixels->data;
              for(y = 0; y < h; y++) {
                PDL_Short *bits = (PDL_Short*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = pdata[(h-1-y)*w + x];
                }
              }
            }
            break;
          case FIT_UINT32:      /* Array of unsigned long: unsigned 32-bit */
            {
              /* XXX-TODO hack: using INT64 for UINT32 */
              PDL_LongLong *pdata = (PDL_LongLong *) pixels->data;
              for(y = 0; y < h; y++) {
                DWORD *bits = (DWORD*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = (DWORD)pdata[(h-1-y)*w + x];
                }
              }
            }
            break;
          case FIT_INT32:       /* Array of long: signed 32-bit */
            {
              PDL_Long *pdata = (PDL_Long *) pixels->data;
              for(y = 0; y < h; y++) {
                PDL_Long *bits = (PDL_Long*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = pdata[(h-1-y)*w + x];
                }
              }
            }
            break;
          case FIT_FLOAT:       /* Array of float: 32-bit IEEE floating point */
            {
              PDL_Float *pdata = (PDL_Float *) pixels->data;
              for(y = 0; y < h; y++) {
                PDL_Float *bits = (PDL_Float*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = pdata[(h-1-y)*w + x];
                }
              }
            }
            break;
          case FIT_DOUBLE:      /* Array of double: 64-bit IEEE floating point */
            {
              PDL_Double *pdata = (PDL_Double *) pixels->data;
              for(y = 0; y < h; y++) {
                PDL_Double *bits = (PDL_Double*)FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = pdata[(h-1-y)*w + x];
                }
              }
            }
            break;
          case FIT_COMPLEX:     /* Array of FICOMPLEX: 2 x 64-bit IEEE floating point */
            /* XXX-TODO not supported */
            break;
          case FIT_RGB16:       /* 48-bit RGB image: 3 x 16-bit */
            {
              PDL_Ushort *pdata = (PDL_Ushort *) pixels->data;
              for(y = 0; y < h; y++) {
                FIRGB16 *bits = (FIRGB16*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x].red   = pdata[(h-1-y)*w + x];
                  bits[x].green = pdata[(h-1-y)*w + x + wxh];
                  bits[x].blue  = pdata[(h-1-y)*w + x + 2*wxh];
                }
              }
            }
            break;
          case FIT_RGBA16:      /* 64-bit RGBA image: 4 x 16-bit */
            {
              PDL_Ushort *pdata = (PDL_Ushort *) pixels->data;
              for(y = 0; y < h; y++) {
                FIRGBA16 *bits = (FIRGBA16*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x].red   = pdata[(h-1-y)*w + x];
                  bits[x].green = pdata[(h-1-y)*w + x + wxh];
                  bits[x].blue  = pdata[(h-1-y)*w + x + 2*wxh];
                  bits[x].alpha = pdata[(h-1-y)*w + x + 3*wxh];
                }
              }
            }
            break;
          case FIT_RGBF:        /* 96-bit RGB float image: 3 x 32-bit IEEE floating point */
            {
              PDL_Float *pdata = (PDL_Float *) pixels->data;
              for(y = 0; y < h; y++) {
                FIRGBF *bits = (FIRGBF*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x].red   = pdata[(h-1-y)*w + x];
                  bits[x].green = pdata[(h-1-y)*w + x + wxh];
                  bits[x].blue  = pdata[(h-1-y)*w + x + 2*wxh];
                }
              }
            }
            break;
          case FIT_RGBAF:       /* 128-bit RGBA float image: 4 x 32-bit IEEE floating point */
            {
              PDL_Float *pdata = (PDL_Float *) pixels->data;
              for(y = 0; y < h; y++) {
                FIRGBAF *bits = (FIRGBAF*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x].red   = pdata[(h-1-y)*w + x];
                  bits[x].green = pdata[(h-1-y)*w + x + wxh];
                  bits[x].blue  = pdata[(h-1-y)*w + x + 2*wxh];
                  bits[x].alpha = pdata[(h-1-y)*w + x + 3*wxh];
                }
              }
            }
            break;
          default:
            warn("FAIL: unknown image type '%d'", fit);
            break;
        }
        
        cu = FreeImage_GetColorsUsed(dib);
        if (palsize > 0 && cu > 0) {
          if (palsize > cu) palsize = cu;
          BYTE *pdata = palette->data;
          RGBQUAD *pal = FreeImage_GetPalette(dib);
          for (i = 0; i < palsize; i++) {
            pal[i].rgbRed      = pdata[i*3];
            pal[i].rgbGreen    = pdata[i*3 + 1];
            pal[i].rgbBlue     = pdata[i*3 + 2];
            pal[i].rgbReserved = 0;
          }
        }
        if (palsize > 0 && cu == 0) {
          warn("ignoring palete piddle");
        }

        Newz(0, RETVAL, 1, struct img_struct);
        if (RETVAL == NULL) croak("FAIL: Newz failed");

        RETVAL->dib = dib;
    }
    OUTPUT:
        RETVAL

const char*
free_image_version()
    CODE:
        RETVAL = FreeImage_GetVersion();
    OUTPUT:
        RETVAL

void
format_list()
    PPCODE:
    {
        int i;
        for(i = 0; i < FreeImage_GetFIFCount(); i++) {
          if(FreeImage_IsPluginEnabled((FREE_IMAGE_FORMAT)i)) {
            const char *f = FreeImage_GetFormatFromFIF((FREE_IMAGE_FORMAT)i);
            XPUSHs(sv_2mortal(newSVpvn(f, strlen(f))));
          }
        }
    }

const char*
format_extension_list(SV *f)
    CODE:
        RETVAL = FreeImage_GetFIFExtensionList(_sv2fif(f));
    OUTPUT:
        RETVAL

const char*
format_mime_type(SV *f)
    CODE:
        RETVAL = FreeImage_GetFIFMimeType(_sv2fif(f));
    OUTPUT:
        RETVAL

const char*
format_description(SV *f)
    CODE:
        RETVAL = FreeImage_GetFIFDescription(_sv2fif(f));
    OUTPUT:
        RETVAL

int
format_enabled(SV *f)
    CODE:
        RETVAL = FreeImage_IsPluginEnabled(_sv2fif(f));
    OUTPUT:
        RETVAL

int
format_can_read(SV *f)
    CODE:
        RETVAL = FreeImage_FIFSupportsReading(_sv2fif(f));
    OUTPUT:
        RETVAL

int
format_can_write(SV *f)
    CODE:
        RETVAL = FreeImage_FIFSupportsWriting(_sv2fif(f));
    OUTPUT:
        RETVAL

int
format_can_export_type(SV *f, int type)
    CODE:
        RETVAL = FreeImage_FIFSupportsExportType(_sv2fif(f), type);
    OUTPUT:
        RETVAL

int
format_can_export_bpp(SV *f, int bpp)
    CODE:
        RETVAL = FreeImage_FIFSupportsExportBPP(_sv2fif(f), bpp);
    OUTPUT:
        RETVAL

const char *
format_from_mime(const char *mime)
    CODE:
        RETVAL = FreeImage_GetFormatFromFIF(FreeImage_GetFIFFromMime(mime));
    OUTPUT:
        RETVAL

const char *
format_from_file(const char *filename)
    CODE:
        int fif = FreeImage_GetFileType(filename, 0);
        if (fif == FIF_UNKNOWN) fif = FreeImage_GetFIFFromFilename(filename);
        RETVAL = FreeImage_GetFormatFromFIF(fif);
    OUTPUT:
        RETVAL

const char*
get_image_type(PDL::IO::Image self)
    CODE:
        RETVAL = _fit2str(FreeImage_GetImageType(self->dib));
    OUTPUT:
        RETVAL

unsigned
get_colors_used(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetColorsUsed(self->dib);
    OUTPUT:
        RETVAL

unsigned
get_bpp(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetBPP(self->dib);
    OUTPUT:
        RETVAL

unsigned
get_width(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetWidth(self->dib);
    OUTPUT:
        RETVAL

unsigned
get_height(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetHeight(self->dib);
    OUTPUT:
        RETVAL

unsigned
get_dots_per_meter_x(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetDotsPerMeterX(self->dib);
    OUTPUT:
        RETVAL

void
set_dots_per_meter_x(PDL::IO::Image self, unsigned res)
    CODE:
        FreeImage_SetDotsPerMeterX(self->dib, res);

unsigned
get_dots_per_meter_y(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetDotsPerMeterY(self->dib);
    OUTPUT:
        RETVAL

void
set_dots_per_meter_y(PDL::IO::Image self, unsigned res)
    CODE:
        FreeImage_SetDotsPerMeterY(self->dib, res);

const char*
get_color_type(PDL::IO::Image self)
    CODE:
        RETVAL = _fic2str(FreeImage_GetColorType(self->dib));
    OUTPUT:
        RETVAL

int
is_transparent(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_IsTransparent(self->dib);
    OUTPUT:
        RETVAL

int
get_transparent_index(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetTransparentIndex(self->dib);
    OUTPUT:
        RETVAL

void
set_transparent_index(PDL::IO::Image self, int index)
    CODE:
        FreeImage_SetTransparentIndex(self->dib, index);

void
flip_horizontal(PDL::IO::Image self)
    CODE:
        FreeImage_FlipHorizontal(self->dib);

void
flip_vertical(PDL::IO::Image self)
    CODE:
        FreeImage_FlipVertical(self->dib);

void
convert_image_type(PDL::IO::Image self, SV * dst_image_type, int scale_linear=1)
    CODE:
    {
        FREE_IMAGE_TYPE fit = _sv2fit(dst_image_type);
        if (fit == FIT_UNKNOWN) {
          warn("invalid dst_image_type");
        }
        else {
          FIBITMAP *newdib = FreeImage_ConvertToType(self->dib, fit, scale_linear);
          if (newdib) {
            if (self->dib) FreeImage_Unload(self->dib);
            self->dib = newdib;
          }
        }
    }

void
tone_mapping(PDL::IO::Image self, int tmo, double p1=0, double p2=0)
    CODE:
    {
        if (tmo == FITMO_DRAGO03 || tmo == FITMO_REINHARD05 || tmo == FITMO_FATTAL02) {
          FIBITMAP *newdib = FreeImage_ToneMapping(self->dib, tmo, p1, p2);
          if (newdib) {
            if (self->dib) FreeImage_Unload(self->dib);
            self->dib = newdib;
          }
        }
        else {
          warn("invalid tone mapping operator");
        }
    }

void
rotate(PDL::IO::Image self, double angle)
    CODE:
    {
        FIBITMAP *newdib = FreeImage_Rotate(self->dib, angle, NULL); /* XXX maybe handle bgcolor */
        if (newdib) {
          if (self->dib) FreeImage_Unload(self->dib);
          self->dib = newdib;
        }
    }

void
rescale(PDL::IO::Image self, int dst_width=0, int dst_height=0, int filter=FILTER_CATMULLROM)
    CODE:
    {
        if (dst_height<=0 && dst_width>0) {
          double ratio = (double)dst_width / (double)FreeImage_GetWidth(self->dib);
          dst_height   = (int)(floor(0.5 + ratio * (double)FreeImage_GetWidth(self->dib)));
        }
        if (dst_width<=0 && dst_height>0) {
          double ratio = (double)dst_height / (double)FreeImage_GetHeight(self->dib);
          dst_width    = (int)(floor(0.5 + ratio * (double)FreeImage_GetHeight(self->dib)));
        }
        if (dst_height>0 && dst_width>0) {
          FIBITMAP *newdib = FreeImage_Rescale(self->dib, dst_width, dst_height, filter);
          if (newdib) {
            if (self->dib) FreeImage_Unload(self->dib);
            self->dib = newdib;
          }
        }
    }

void
save(PDL::IO::Image self, const char *filename, SV * f=NULL, int flags=0);
    CODE:
    {
        if (self->dib) {
          FREE_IMAGE_FORMAT fif = _sv2fif(f);
          if (fif == FIF_UNKNOWN) fif = FreeImage_GetFIFFromFilename(filename);
          if (fif == FIF_UNKNOWN) croak("FAIL: unspecified format");
          FreeImage_Save(fif, self->dib, filename, flags);
        }
    }

pdl*
palette_to_pdl(PDL::IO::Image self)
    CODE:
    {
        pdl *pal_pdl = NULL;
        PDL_Indx dims[] = {0, 0, 0};
        int cu = FreeImage_GetColorsUsed(self->dib);
        if (cu==0) XSRETURN_UNDEF;

        PDL_Byte *pdata;
        int i;
        dims[0] = 3;
        dims[1] = cu;
        pal_pdl = PDL->pdlnew();
        pal_pdl->datatype = PDL_B;
        PDL->setdims (pal_pdl, dims, 2);
        PDL->allocdata (pal_pdl);
        pdata = (PDL_Byte *) pal_pdl->data;
        RGBQUAD *pal = FreeImage_GetPalette(self->dib);
        for (i = 0; i < cu; i++) {
          pdata[i*3]     = (PDL_Byte) pal[i].rgbRed;
          pdata[i*3 + 1] = (PDL_Byte) pal[i].rgbGreen;
          pdata[i*3 + 2] = (PDL_Byte) pal[i].rgbBlue;
        }
        RETVAL = pal_pdl;
    }
    OUTPUT:
        RETVAL

pdl*
pixels_to_pdl(PDL::IO::Image self, unsigned long x1=0, unsigned long x2=0, unsigned long y1=0, unsigned long y2=0)
    CODE:
    {
        pdl *bmp_pdl = NULL;
        PDL_Indx dims[] = {0, 0, 0};
        PDL_Indx x, y, wxh;
        unsigned long w, h;
        int bpp, it;

        w   = FreeImage_GetWidth(self->dib);
        h   = FreeImage_GetHeight(self->dib);
        bpp = FreeImage_GetBPP(self->dib);
        it  = FreeImage_GetImageType(self->dib);

        /* handle region selection */
        if (x1 > 0) w -= x1;
        if (y1 > 0) h -= y1;
        if (x2 > x1 && w > (x2 - x1)) w = (x2 - x1);
        if (y2 > y1 && h > (y2 - y1)) h = (y2 - y1);
        wxh = w * h;

        if (!FreeImage_HasPixels(self->dib)) {
          warn("FAIL: no pixels");
          XSRETURN_UNDEF;
        }

        switch (it) {
          case FIT_BITMAP:      /* Standard image: 1-, 4-, 8-, 16-, 24-, 32-bit */
            if (bpp==32) {
              PDL_Byte *pdata;
              dims[0] = w;
              dims[1] = h;
              dims[2] = 4;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_B;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Byte *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                RGBQUAD *bits = (RGBQUAD*) FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x]         = (PDL_Byte) bits[x+x1].rgbRed;
                  pdata[(h-1-y)*w + x + wxh]   = (PDL_Byte) bits[x+x1].rgbGreen;
                  pdata[(h-1-y)*w + x + 2*wxh] = (PDL_Byte) bits[x+x1].rgbBlue;
                  pdata[(h-1-y)*w + x + 3*wxh] = (PDL_Byte) bits[x+x1].rgbReserved;
                }
              }
            }
            else if (bpp==24) {
              PDL_Byte *pdata;
              dims[0] = w;
              dims[1] = h;
              dims[2] = 3;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_B;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Byte *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                RGBTRIPLE *bits = (RGBTRIPLE*) FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x]         = (PDL_Byte) bits[x+x1].rgbtRed;
                  pdata[(h-1-y)*w + x + wxh]   = (PDL_Byte) bits[x+x1].rgbtGreen;
                  pdata[(h-1-y)*w + x + 2*wxh] = (PDL_Byte) bits[x+x1].rgbtBlue;
                }
              }
            }
            else if (bpp==16) {
              unsigned red_mask, green_mask, blue_mask;
              PDL_Byte *pdata;
              dims[0] = w;
              dims[1] = h;
              dims[2] = 3;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_B;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Byte *) bmp_pdl->data;
              red_mask   = FreeImage_GetRedMask(self->dib);
              green_mask = FreeImage_GetGreenMask(self->dib);
              blue_mask  = FreeImage_GetBlueMask(self->dib);
              if ( (red_mask == FI16_565_RED_MASK) && (green_mask == FI16_565_GREEN_MASK) && (blue_mask == FI16_565_BLUE_MASK) ) {
                for(y = 0; y < h; y++) {
                  WORD *bits = (WORD*)FreeImage_GetScanLine(self->dib, y+y1);
                  for(x = 0; x < w; x++) {
                    pdata[(h-1-y)*w + x]         = (PDL_Byte) ((bits[x+x1] & FI16_565_RED_MASK)   >> FI16_565_RED_SHIFT);
                    pdata[(h-1-y)*w + x + wxh]   = (PDL_Byte) ((bits[x+x1] & FI16_565_GREEN_MASK) >> FI16_565_GREEN_SHIFT);
                    pdata[(h-1-y)*w + x + 2*wxh] = (PDL_Byte) ((bits[x+x1] & FI16_565_BLUE_MASK)  >> FI16_565_BLUE_SHIFT);
                  }
                }
              }
              else {
                for(y = 0; y < h; y++) {
                  WORD *bits = (WORD*)FreeImage_GetScanLine(self->dib, y+y1);
                  for(x = 0; x < w; x++) {
                    pdata[(h-1-y)*w + x]         = (PDL_Byte) ((bits[x+x1] & FI16_555_RED_MASK)   >> FI16_555_RED_SHIFT);
                    pdata[(h-1-y)*w + x + wxh]   = (PDL_Byte) ((bits[x+x1] & FI16_555_GREEN_MASK) >> FI16_555_GREEN_SHIFT);
                    pdata[(h-1-y)*w + x + 2*wxh] = (PDL_Byte) ((bits[x+x1] & FI16_555_BLUE_MASK)  >> FI16_555_BLUE_SHIFT);
                  }
                }
              }
            }
            else if (bpp==8) {
              PDL_Byte *pdata;
              dims[0] = w;
              dims[1] = h;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_B;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Byte *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                BYTE *bits = FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x] = (PDL_Byte) bits[x+x1];
                }
              }
            }
            else if (bpp==4) {
              PDL_Byte *pdata;
              dims[0] = w;
              dims[1] = h;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_B;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Byte *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                BYTE *bits = FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x] = (PDL_Byte) ((bits[(x+x1)/2] >> 4*(1-(x+x1)%2)) & 0x0F);
                }
              }
            }
            else if (bpp==1) {
              PDL_Byte *pdata;
              dims[0] = w;
              dims[1] = h;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_B;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Byte *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                BYTE *bits = FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x] = (PDL_Byte) ((bits[(x+x1)/8] >> (7-(x+x1)%8)) & 0x01);
                }
              }
            }
            else {
              warn("FAIL: unknown bits per pixel '%d'", bpp);
            }
            break;
          case FIT_UINT16:      /* Array of unsigned short: unsigned 16-bit */
            {
              PDL_Ushort *pdata;
              dims[0] = w;
              dims[1] = h;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_US;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Ushort *) bmp_pdl->data;

              for(y = 0; y < h; y++) {
                PDL_Ushort *bits = (PDL_Ushort*)FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x] = bits[x+x1];
                }
              }
            }
            break;
          case FIT_INT16:       /* Array of short: signed 16-bit */
            {
              PDL_Short *pdata;
              dims[0] = w;
              dims[1] = h;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_S;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Short *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                PDL_Short *bits = (PDL_Short*)FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x] = bits[x+x1];
                }
              }
            }
            break;
          case FIT_UINT32:      /* Array of unsigned long: unsigned 32-bit */
            { /* XXX-TODO hack: using INT64 for UINT32 */
              PDL_LongLong *pdata;
              dims[0] = w;
              dims[1] = h;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_LL;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_LongLong *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                DWORD *bits = (DWORD*)FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x] = (PDL_LongLong)bits[x+x1];
                }
              }
            }
            break;
          case FIT_INT32:       /* Array of long: signed 32-bit */
            {
              PDL_Long *pdata;
              dims[0] = w;
              dims[1] = h;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_L;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Long *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                PDL_Long *bits = (PDL_Long*)FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x] = bits[x+x1];
                }
              }
            }
            break;
          case FIT_FLOAT:       /* Array of float: 32-bit IEEE floating point */
            {
              PDL_Float *pdata;
              dims[0] = w;
              dims[1] = h;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_F;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Float *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                PDL_Float *bits = (PDL_Float*)FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x] = bits[x+x1];
                }
              }
            }
            break;
          case FIT_DOUBLE:      /* Array of double: 64-bit IEEE floating point */
            {
              PDL_Double *pdata;
              dims[0] = w;
              dims[1] = h;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_D;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Double *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                PDL_Double *bits = (PDL_Double*)FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x] = bits[x+x1];
                }
              }
            }
            break;
          case FIT_COMPLEX:     /* Array of FICOMPLEX: 2 x 64-bit IEEE floating point */
            warn("FAIL: FIT_COMPLEX not supported");
            /* for(y = 0; y < h; y++) {
             *   FICOMPLEX *bits = (FICOMPLEX *)FreeImage_GetScanLine(self->dib, y+y1);
             *   for(x = 0; x < w; x++) {
             *     pdata[(h-1-y)*w + x] = (PDL_Double) bits[x+x1].r;
             *     pdata[(h-1-y)*w + x] = (PDL_Double) bits[x+x1].i;
             *   }
             * }
             */
            break;
          case FIT_RGB16:       /* 48-bit RGB image: 3 x 16-bit */
            {
              PDL_Ushort *pdata;
              dims[0] = w;
              dims[1] = h;
              dims[2] = 3;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_US;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Ushort *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                FIRGB16 *bits = (FIRGB16*) FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x]         = (PDL_Ushort) bits[x+x1].red;
                  pdata[(h-1-y)*w + x + wxh]   = (PDL_Ushort) bits[x+x1].green;
                  pdata[(h-1-y)*w + x + 2*wxh] = (PDL_Ushort) bits[x+x1].blue;
                }
              }
            }
            break;
          case FIT_RGBA16:      /* 64-bit RGBA image: 4 x 16-bit */
            {
              PDL_Ushort *pdata;
              dims[0] = w;
              dims[1] = h;
              dims[2] = 4;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_US;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Ushort *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                FIRGBA16 *bits = (FIRGBA16*) FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x]         = (PDL_Ushort) bits[x+x1].red;
                  pdata[(h-1-y)*w + x + wxh]   = (PDL_Ushort) bits[x+x1].green;
                  pdata[(h-1-y)*w + x + 2*wxh] = (PDL_Ushort) bits[x+x1].blue;
                  pdata[(h-1-y)*w + x + 3*wxh] = (PDL_Ushort) bits[x+x1].alpha;
                }
              }
            }
            break;
          case FIT_RGBF:        /* 96-bit RGB float image: 3 x 32-bit IEEE floating point */
            {
              PDL_Float *pdata;
              dims[0] = w;
              dims[1] = h;
              dims[2] = 3;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_F;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Float *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                FIRGBF *bits = (FIRGBF*) FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x]         = (PDL_Float) bits[x+x1].red;
                  pdata[(h-1-y)*w + x + wxh]   = (PDL_Float) bits[x+x1].green;
                  pdata[(h-1-y)*w + x + 2*wxh] = (PDL_Float) bits[x+x1].blue;
                }
              }
            }
            break;
          case FIT_RGBAF:       /* 128-bit RGBA float image: 4 x 32-bit IEEE floating point */
            {
              PDL_Float *pdata;
              dims[0] = w;
              dims[1] = h;
              dims[2] = 4;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_F;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Float *) bmp_pdl->data;
              for(y = 0; y < h; y++) {
                FIRGBAF *bits = (FIRGBAF*) FreeImage_GetScanLine(self->dib, y+y1);
                for(x = 0; x < w; x++) {
                  pdata[(h-1-y)*w + x]         = (PDL_Float) bits[x+x1].red;
                  pdata[(h-1-y)*w + x + wxh]   = (PDL_Float) bits[x+x1].green;
                  pdata[(h-1-y)*w + x + 2*wxh] = (PDL_Float) bits[x+x1].blue;
                  pdata[(h-1-y)*w + x + 3*wxh] = (PDL_Float) bits[x+x1].alpha;
                }
              }
            }
            break;
          default:
            warn("FAIL: unknown image type '%d'", it);
            break;
        }

        if (bmp_pdl == NULL) XSRETURN_UNDEF;
        RETVAL = bmp_pdl;
    }
    OUTPUT:
        RETVAL

void
DESTROY(self)
        PDL::IO::Image self
    CODE:
        if (self->dib != NULL) FreeImage_Unload(self->dib);
        Safefree(self);

ENDXS

############################################################### PM part
###pp_add_exported('pm_demo');
pp_addpm( <<'ENDPM' );
use strict;
use warnings;
use Carp;

sub pm_demo {
  warn "pm_demo\n";
  warn "ref(self)=",ref($_[0]),"\n";
  return 12345;
}
ENDPM

############################################################### Constants part
use ExtUtils::Constant qw (WriteConstants);

my @C = (
    ### load/save flags
    { type=>'IV', name=>'BMP_SAVE_RLE' },
    { type=>'IV', name=>'EXR_FLOAT' },
    { type=>'IV', name=>'EXR_NONE' },
    { type=>'IV', name=>'EXR_ZIP' },
    { type=>'IV', name=>'EXR_PIZ' },
    { type=>'IV', name=>'EXR_PXR24' },
    { type=>'IV', name=>'EXR_B44' },
    { type=>'IV', name=>'EXR_LC' },
    { type=>'IV', name=>'GIF_LOAD256' },
    { type=>'IV', name=>'GIF_PLAYBACK' },
    { type=>'IV', name=>'ICO_MAKEALPHA' },
    { type=>'IV', name=>'JPEG_FAST' },
    { type=>'IV', name=>'JPEG_ACCURATE' },
    { type=>'IV', name=>'JPEG_CMYK' },
    { type=>'IV', name=>'JPEG_EXIFROTATE' },
    { type=>'IV', name=>'JPEG_GREYSCALE' },
    { type=>'IV', name=>'JPEG_QUALITYSUPERB' },
    { type=>'IV', name=>'JPEG_QUALITYGOOD' },
    { type=>'IV', name=>'JPEG_QUALITYNORMAL' },
    { type=>'IV', name=>'JPEG_QUALITYAVERAGE' },
    { type=>'IV', name=>'JPEG_QUALITYBAD' },
    { type=>'IV', name=>'JPEG_PROGRESSIVE' },
    { type=>'IV', name=>'JPEG_SUBSAMPLING_411' },
    { type=>'IV', name=>'JPEG_SUBSAMPLING_420' },
    { type=>'IV', name=>'JPEG_SUBSAMPLING_422' },
    { type=>'IV', name=>'JPEG_SUBSAMPLING_444' },
    { type=>'IV', name=>'JPEG_OPTIMIZE' },
    { type=>'IV', name=>'JPEG_BASELINE' },
    { type=>'IV', name=>'PCD_BASE' },
    { type=>'IV', name=>'PCD_BASEDIV4' },
    { type=>'IV', name=>'PCD_BASEDIV16' },
    { type=>'IV', name=>'PNG_IGNOREGAMMA' },
    { type=>'IV', name=>'PNG_Z_BEST_SPEED' },
    { type=>'IV', name=>'PNG_Z_DEFAULT_COMPRESSION' },
    { type=>'IV', name=>'PNG_Z_BEST_COMPRESSION' },
    { type=>'IV', name=>'PNG_Z_NO_COMPRESSION' },
    { type=>'IV', name=>'PNG_INTERLACED' },
    { type=>'IV', name=>'PNM_SAVE_ASCII' },
    { type=>'IV', name=>'PSD_CMYK' },
    { type=>'IV', name=>'PSD_LAB' },
    { type=>'IV', name=>'RAW_PREVIEW' },
    { type=>'IV', name=>'RAW_DISPLAY' },
    { type=>'IV', name=>'RAW_HALFSIZE' },
    { type=>'IV', name=>'TARGA_LOAD_RGB888' },
    { type=>'IV', name=>'TARGA_SAVE_RLE' },
    { type=>'IV', name=>'TIFF_CMYK' },
    { type=>'IV', name=>'TIFF_PACKBITS' },
    { type=>'IV', name=>'TIFF_DEFLATE' },
    { type=>'IV', name=>'TIFF_ADOBE_DEFLATE' },
    { type=>'IV', name=>'TIFF_NONE' },
    { type=>'IV', name=>'TIFF_CCITTFAX3' },
    { type=>'IV', name=>'TIFF_CCITTFAX4' },
    { type=>'IV', name=>'TIFF_LZW' },
    { type=>'IV', name=>'TIFF_JPEG' },
    { type=>'IV', name=>'TIFF_LOGLUV' },
    { type=>'IV', name=>'WEBP_LOSSLESS' },
    { type=>'IV', name=>'JXR_LOSSLESS' },
    { type=>'IV', name=>'JXR_PROGRESSIVE' },
);

WriteConstants(NAME => 'PDL::IO::Image', NAMES => [ map { { macro=>1,type=>$_->{type},name=>$_->{name}} } @C ]);
pp_addpm("### Constants");
pp_add_exported(map {$_->{name}} @C);
pp_addpm("sub $_->{name}() { (constant('$_->{name}'))[1] }") for (@C);

############################################################### POD part
pp_addpm(<<'ENDPOD');
=head1 NAME

PDL::IO::Image - Load/save bitmap from/to PDL (via FreeImage library)

XXX-TODO add pod doc here

=cut
ENDPOD
