use strict;
use strict;
use warnings;
our $VERSION = '0.001';

pp_setversion($VERSION);

############################################################### C part
pp_addhdr(<<'ENDHDR');

#include <FreeImage.h>

typedef struct img_struct {
  FIBITMAP *dib;
  int id;
} *PDL__IO__Image;

FREE_IMAGE_FORMAT _sv2fif(SV *f)
{
  int i;
  if (f == NULL) return FIF_UNKNOWN;
  if (!SvOK(f)) return FIF_UNKNOWN;
  if (SvIOK(f)) {
    i = SvIV(f);
    if (FreeImage_IsPluginEnabled((FREE_IMAGE_FORMAT)i)) return (FREE_IMAGE_FORMAT)i;
  }
  if (SvPOK(f)) {
    return FreeImage_GetFIFFromFormat(SvPV_nolen(f));
  }
  return FIF_UNKNOWN;
}

FREE_IMAGE_TYPE _sv2fit(SV *f)
{
  int i;
  if (f == NULL) return FIT_UNKNOWN;
  if (!SvOK(f)) return FIT_UNKNOWN;
  if (SvIOK(f)) {
    i = SvIV(f);
    if ( i == FIT_BITMAP  ||
         i == FIT_UINT16  ||
         i == FIT_INT16   ||
         i == FIT_UINT32  ||
         i == FIT_INT32   ||
         i == FIT_FLOAT   ||
         i == FIT_DOUBLE  ||
         i == FIT_COMPLEX ||
         i == FIT_RGB16   ||
         i == FIT_RGBA16  ||
         i == FIT_RGBF    ||
         i == FIT_RGBAF ) return (FREE_IMAGE_TYPE)i;
  }
  if (SvPOK(f)) {
    char *name = SvPV_nolen(f);
    if (memEQ(name, "BITMAP",  6)) return FIT_BITMAP;
    if (memEQ(name, "UINT16",  6)) return FIT_UINT16;
    if (memEQ(name, "INT16",   5)) return FIT_INT16;
    if (memEQ(name, "UINT32",  6)) return FIT_UINT32;
    if (memEQ(name, "INT32",   5)) return FIT_INT32;
    if (memEQ(name, "FLOAT",   5)) return FIT_FLOAT;
    if (memEQ(name, "DOUBLE",  6)) return FIT_DOUBLE;
    if (memEQ(name, "COMPLEX", 7)) return FIT_COMPLEX;
    if (memEQ(name, "RGB16",   5)) return FIT_RGB16;
    if (memEQ(name, "RGBA16",  6)) return FIT_RGBA16;
    if (memEQ(name, "RGBF",    4)) return FIT_RGBF;
    if (memEQ(name, "RGBAF",   5)) return FIT_RGBAF;
  }
  return FIT_UNKNOWN;
}

void _pdl2imparams(pdl *pix, pdl *pal, FREE_IMAGE_TYPE *fit, unsigned *width, unsigned *height, int *bpp, int *palsize)
{
  int ty = -1, di = -1;
  PDL_Indx i, n;
  PDL_Byte *bptr = NULL, bmax = 0;
  *fit = FIT_UNKNOWN;
  *bpp = 0;
  *palsize = 0;

  if (pix == NULL) return;

  ty = pix->datatype;
  di = pix->ndims;

  if (pal != NULL) {
    if ( pal->datatype == PDL_B &&
         pal->ndims == 2 &&
         pal->dims[0] == 3 &&
         pal->dims[1] > 0 &&
         pal->dims[1] <= 256 ) *palsize = pal->dims[1];
    if (*palsize == 0) {
      warn("wrong palette piddle, has to be Byte[3, n] (0 < n <= 256)");
    }
  }

  if (di == 2) {
    *width  = pix->dims[0];
    *height = pix->dims[1];
    n = pix->dims[0] * pix->dims[1];
    if (ty == PDL_D ) { *bpp = 64; *fit = FIT_DOUBLE; }
    if (ty == PDL_F ) { *bpp = 32; *fit = FIT_FLOAT;  }
    if (ty == PDL_L ) { *bpp = 32; *fit = FIT_INT32;  }
    if (ty == PDL_LL) { *bpp = 32; *fit = FIT_UINT32; } /* XXX-TODO hack: using INT64 for UINT32 */
    if (ty == PDL_S ) { *bpp = 16; *fit = FIT_INT16;  }
    if (ty == PDL_US) { *bpp = 16; *fit = FIT_UINT16; }
    if (ty == PDL_B ) {
      *fit = FIT_BITMAP;
      /* bpp detection based on max used values */
      for(bptr=(PDL_Byte *)pix->data, i=0; i<n; i++) { if(bptr[i]>bmax) bmax=bptr[i]; }
      if (bmax < 2)          { *bpp = 1; }
      else if (bmax < 16)    { *bpp = 4; }
      else                   { *bpp = 8; }
      /* bpp correction based on pallete size */
      if (*palsize > 16)     { *bpp = 8; }
      else if (*palsize > 2) { *bpp = 4; }
      else if (*palsize > 0) { *bpp = 1; }
    }
  }
  if (di == 3) {
    *width  = pix->dims[0];
    *height = pix->dims[1];
    n = pix->dims[0] * pix->dims[1] * pix->dims[2];
    if (pix->dims[2] == 3) {
      if (ty == PDL_F ) { *bpp = 96; *fit = FIT_RGBF;   }
      if (ty == PDL_US) { *bpp = 48; *fit = FIT_RGB16;  }
      if (ty == PDL_B ) { *bpp = 24; *fit = FIT_BITMAP; } /* XXX-TODO handle 16bpp */
    }
    if (pix->dims[2] == 4) {
      if (ty == PDL_F ) { *bpp =128; *fit = FIT_RGBAF;  }
      if (ty == PDL_US) { *bpp = 64; *fit = FIT_RGBA16; }
      if (ty == PDL_B ) { *bpp = 32; *fit = FIT_BITMAP; } /* XXX-TODO handle 16bpp */
    }
  }

  if (*bpp == 0) {
    warn("wrong pixel pdl, has to be: D|F|L|LL|S|US|B[w,h] F|US|B[w,h,3] F|US|B[w,h,3]");
  }
}


const char* _fit2str(FREE_IMAGE_TYPE f)
{
  if (f == FIT_BITMAP  ) return "BITMAP";
  if (f == FIT_UINT16  ) return "UINT16";
  if (f == FIT_INT16   ) return "INT16";
  if (f == FIT_UINT32  ) return "UINT32";
  if (f == FIT_INT32   ) return "INT32";
  if (f == FIT_FLOAT   ) return "FLOAT";
  if (f == FIT_DOUBLE  ) return "DOUBLE";
  if (f == FIT_COMPLEX ) return "COMPLEX";
  if (f == FIT_RGB16   ) return "RGB16";
  if (f == FIT_RGBA16  ) return "RGBA16";
  if (f == FIT_RGBF    ) return "RGBF";
  if (f == FIT_RGBAF   ) return "RGBAF";
  return "";
}

const char* _fic2str(FREE_IMAGE_COLOR_TYPE c)
{
  if (c == FIC_MINISWHITE) return "MINISWHITE";
  if (c == FIC_MINISBLACK) return "MINISBLACK";
  if (c == FIC_RGB       ) return "RGB";
  if (c == FIC_PALETTE   ) return "PALETTE";
  if (c == FIC_RGBALPHA  ) return "RGBALPHA";
  if (c == FIC_CMYK      ) return "CMYK";
  return "";
}

#include "const-c.inc"

ENDHDR

############################################################# XS part
pp_addxs('', <<'ENDXS' );

BOOT:
        FreeImage_Initialise(FALSE);

INCLUDE: const-xs.inc

PDL::IO::Image
new_from_file(char * class, char * filename, SV *f=NULL, int flags=0, int page=0)
    CODE:
    {
        FIBITMAP *dib = NULL;
        FREE_IMAGE_FORMAT fif = _sv2fif(f);
        if (fif == FIF_UNKNOWN) fif = FreeImage_GetFileType(filename, 0);
        if (fif == FIF_UNKNOWN) fif = FreeImage_GetFIFFromFilename(filename);
        if (fif == FIF_UNKNOWN) croak("FAIL: unknown format '%s'", filename);

        if (page > 0) {
          FIMULTIBITMAP * multi = FreeImage_OpenMultiBitmap(fif, filename, FALSE, TRUE, FALSE, flags);
          if (multi) {
            int count = FreeImage_GetPageCount(multi);
            if (page < count) {
              FIBITMAP *page_dib = FreeImage_LockPage(multi, page);
              dib = FreeImage_Clone(page_dib);
              FreeImage_UnlockPage(multi, page_dib, FALSE);
            }
            else {
              warn("invalid page index '%d' (max=%d)", page, count-1);
            }
            FreeImage_CloseMultiBitmap(multi, 0);
          }
          else {
            warn("cannot open '%s' as multi page image", filename);
          }
        }
        else {
          dib = FreeImage_Load(fif, filename, flags);
        }

        if (dib == NULL) croak("FAIL: cannot load '%s'", filename);
        Newz(0, RETVAL, 1, struct img_struct);
        if (RETVAL == NULL) croak("FAIL: Newz failed");

        RETVAL->dib = dib;
    }
    OUTPUT:
        RETVAL

PDL::IO::Image
new_from_pdl(char * class, pdl * pixels, pdl * palette=NULL)
    CODE:
    {
        FIBITMAP *dib = NULL;
        FREE_IMAGE_TYPE fit = FIT_UNKNOWN;
        int bpp = 0, palsize = 0;
        unsigned w = 0, h = 0, cu = 0, i;
        PDL_Indx x, y, wxh;

        _pdl2imparams(pixels, palette, &fit, &w, &h, &bpp, &palsize);
        if (fit == FIT_UNKNOWN) croak("FAIL: invalid PDL");

        dib = FreeImage_AllocateT(fit, w, h, bpp, 0, 0, 0);
        if (dib == NULL) croak("FAIL: cannot create bitmap from PDL");

        wxh = w * h;

        switch (fit) {
          case FIT_BITMAP:      /* Standard image: 1-, 4-, 8-, 16-, 24-, 32-bit */
            if (bpp==32) {
              BYTE *pdata = pixels->data;
              for(y = 0; y < h; y++) {
                RGBQUAD *bits = (RGBQUAD*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x].rgbRed      = pdata[(h-1-y)*w + x];
                  bits[x].rgbGreen    = pdata[(h-1-y)*w + x + wxh];
                  bits[x].rgbBlue     = pdata[(h-1-y)*w + x + 2*wxh];
                  bits[x].rgbReserved = pdata[(h-1-y)*w + x + 3*wxh];
                }
              }
            }
            else if (bpp==24) {
              BYTE *pdata = pixels->data;
              for(y = 0; y < h; y++) {
                RGBTRIPLE *bits = (RGBTRIPLE*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x].rgbtRed   = pdata[(h-1-y)*w + x];
                  bits[x].rgbtGreen = pdata[(h-1-y)*w + x + wxh];
                  bits[x].rgbtBlue  = pdata[(h-1-y)*w + x + 2*wxh];
                }
              }
            }
            else if (bpp==8) {
              BYTE *pdata = pixels->data;
              for(y = 0; y < h; y++) {
                BYTE *bits = FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = pdata[(h-1-y)*w + x];
                }
              }
            }
            else if (bpp==4) {
              BYTE *pdata = pixels->data;
              for(y = 0; y < h; y++) {
                BYTE *bits = FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x/2] |= (pdata[(h-1-y)*w + x] & 0x0F) << 4*(1-x%2);
                }
              }
            }
            else if (bpp==1) {
              BYTE *pdata = pixels->data;
              for(y = 0; y < h; y++) {
                BYTE *bits = FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x/8] |= (pdata[(h-1-y)*w + x] & 0x01) << (7-x%8);
                }
              }
            }
            else {
              warn("FAIL: unknown bits per pixel '%d'", bpp);
            }
            break;
          case FIT_UINT16:      /* Array of unsigned short: unsigned 16-bit */
            {
              PDL_Ushort *pdata = (PDL_Ushort *) pixels->data;
              for(y = 0; y < h; y++) {
                PDL_Ushort *bits = (PDL_Ushort*)FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = pdata[(h-1-y)*w + x];
                }
              }
            }
            break;
          case FIT_INT16:       /* Array of short: signed 16-bit */
            {
              PDL_Short *pdata = (PDL_Short *) pixels->data;
              for(y = 0; y < h; y++) {
                PDL_Short *bits = (PDL_Short*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = pdata[(h-1-y)*w + x];
                }
              }
            }
            break;
          case FIT_UINT32:      /* Array of unsigned long: unsigned 32-bit */
            {
              /* XXX-TODO hack: using INT64 for UINT32 */
              PDL_LongLong *pdata = (PDL_LongLong *) pixels->data;
              for(y = 0; y < h; y++) {
                DWORD *bits = (DWORD*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = (DWORD)pdata[(h-1-y)*w + x];
                }
              }
            }
            break;
          case FIT_INT32:       /* Array of long: signed 32-bit */
            {
              PDL_Long *pdata = (PDL_Long *) pixels->data;
              for(y = 0; y < h; y++) {
                PDL_Long *bits = (PDL_Long*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = pdata[(h-1-y)*w + x];
                }
              }
            }
            break;
          case FIT_FLOAT:       /* Array of float: 32-bit IEEE floating point */
            {
              PDL_Float *pdata = (PDL_Float *) pixels->data;
              for(y = 0; y < h; y++) {
                PDL_Float *bits = (PDL_Float*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = pdata[(h-1-y)*w + x];
                }
              }
            }
            break;
          case FIT_DOUBLE:      /* Array of double: 64-bit IEEE floating point */
            {
              PDL_Double *pdata = (PDL_Double *) pixels->data;
              for(y = 0; y < h; y++) {
                PDL_Double *bits = (PDL_Double*)FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x] = pdata[(h-1-y)*w + x];
                }
              }
            }
            break;
          case FIT_COMPLEX:     /* Array of FICOMPLEX: 2 x 64-bit IEEE floating point */
            /* XXX-TODO not supported */
            break;
          case FIT_RGB16:       /* 48-bit RGB image: 3 x 16-bit */
            {
              PDL_Ushort *pdata = (PDL_Ushort *) pixels->data;
              for(y = 0; y < h; y++) {
                FIRGB16 *bits = (FIRGB16*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x].red   = pdata[(h-1-y)*w + x];
                  bits[x].green = pdata[(h-1-y)*w + x + wxh];
                  bits[x].blue  = pdata[(h-1-y)*w + x + 2*wxh];
                }
              }
            }
            break;
          case FIT_RGBA16:      /* 64-bit RGBA image: 4 x 16-bit */
            {
              PDL_Ushort *pdata = (PDL_Ushort *) pixels->data;
              for(y = 0; y < h; y++) {
                FIRGBA16 *bits = (FIRGBA16*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x].red   = pdata[(h-1-y)*w + x];
                  bits[x].green = pdata[(h-1-y)*w + x + wxh];
                  bits[x].blue  = pdata[(h-1-y)*w + x + 2*wxh];
                  bits[x].alpha = pdata[(h-1-y)*w + x + 3*wxh];
                }
              }
            }
            break;
          case FIT_RGBF:        /* 96-bit RGB float image: 3 x 32-bit IEEE floating point */
            {
              PDL_Float *pdata = (PDL_Float *) pixels->data;
              for(y = 0; y < h; y++) {
                FIRGBF *bits = (FIRGBF*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x].red   = pdata[(h-1-y)*w + x];
                  bits[x].green = pdata[(h-1-y)*w + x + wxh];
                  bits[x].blue  = pdata[(h-1-y)*w + x + 2*wxh];
                }
              }
            }
            break;
          case FIT_RGBAF:       /* 128-bit RGBA float image: 4 x 32-bit IEEE floating point */
            {
              PDL_Float *pdata = (PDL_Float *) pixels->data;
              for(y = 0; y < h; y++) {
                FIRGBAF *bits = (FIRGBAF*) FreeImage_GetScanLine(dib, y);
                for(x = 0; x < w; x++) {
                  bits[x].red   = pdata[(h-1-y)*w + x];
                  bits[x].green = pdata[(h-1-y)*w + x + wxh];
                  bits[x].blue  = pdata[(h-1-y)*w + x + 2*wxh];
                  bits[x].alpha = pdata[(h-1-y)*w + x + 3*wxh];
                }
              }
            }
            break;
          default:
            warn("FAIL: unknown image type '%d'", fit);
            break;
        }

        cu = FreeImage_GetColorsUsed(dib);
        if (palsize > 0 && cu > 0) {
          if (palsize > cu) palsize = cu;
          BYTE *pdata = palette->data;
          RGBQUAD *pal = FreeImage_GetPalette(dib);
          for (i = 0; i < palsize; i++) {
            pal[i].rgbRed      = pdata[i*3];
            pal[i].rgbGreen    = pdata[i*3 + 1];
            pal[i].rgbBlue     = pdata[i*3 + 2];
            pal[i].rgbReserved = 0;
          }
        }
        if (palsize > 0 && cu == 0) {
          warn("ignoring palete piddle");
        }

        Newz(0, RETVAL, 1, struct img_struct);
        if (RETVAL == NULL) croak("FAIL: Newz failed");

        RETVAL->dib = dib;
    }
    OUTPUT:
        RETVAL

const char*
free_image_version(SV *class)
    CODE:
        RETVAL = FreeImage_GetVersion();
    OUTPUT:
        RETVAL

void
format_list(SV *class)
    PPCODE:
    {
        int i;
        for(i = 0; i < FreeImage_GetFIFCount(); i++) {
          if(FreeImage_IsPluginEnabled((FREE_IMAGE_FORMAT)i)) {
            const char *f = FreeImage_GetFormatFromFIF((FREE_IMAGE_FORMAT)i);
            XPUSHs(sv_2mortal(newSVpvn(f, strlen(f))));
          }
        }
    }

const char*
format_extension_list(SV *class, SV *f)
    CODE:
        RETVAL = FreeImage_GetFIFExtensionList(_sv2fif(f));
    OUTPUT:
        RETVAL

const char*
format_mime_type(SV *class, SV *f)
    CODE:
        RETVAL = FreeImage_GetFIFMimeType(_sv2fif(f));
    OUTPUT:
        RETVAL

const char*
format_description(SV *class, SV *f)
    CODE:
        RETVAL = FreeImage_GetFIFDescription(_sv2fif(f));
    OUTPUT:
        RETVAL

int
format_can_read(SV *class, SV *f)
    CODE:
        RETVAL = FreeImage_IsPluginEnabled(_sv2fif(f)) && FreeImage_FIFSupportsReading(_sv2fif(f));
    OUTPUT:
        RETVAL

int
format_can_write(SV *class, SV *f)
    CODE:
        RETVAL = FreeImage_IsPluginEnabled(_sv2fif(f)) && FreeImage_FIFSupportsWriting(_sv2fif(f));
    OUTPUT:
        RETVAL

int
format_can_export_type(SV *class, SV *f, SV *t)
    CODE:
        RETVAL = FreeImage_FIFSupportsExportType(_sv2fif(f), _sv2fit(t));
    OUTPUT:
        RETVAL

int
format_can_export_bpp(SV *class, SV *f, int bpp)
    CODE:
        RETVAL = FreeImage_FIFSupportsExportBPP(_sv2fif(f), bpp);
    OUTPUT:
        RETVAL

const char *
format_from_mime(SV *class, const char *mime)
    CODE:
        RETVAL = FreeImage_GetFormatFromFIF(FreeImage_GetFIFFromMime(mime));
    OUTPUT:
        RETVAL

const char *
format_from_file(SV *class, const char *filename)
    CODE:
        int fif = FreeImage_GetFileType(filename, 0);
        if (fif == FIF_UNKNOWN) fif = FreeImage_GetFIFFromFilename(filename);
        RETVAL = FreeImage_GetFormatFromFIF(fif);
    OUTPUT:
        RETVAL

const char*
get_image_type(PDL::IO::Image self)
    CODE:
        RETVAL = _fit2str(FreeImage_GetImageType(self->dib));
    OUTPUT:
        RETVAL

unsigned
get_colors_used(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetColorsUsed(self->dib);
    OUTPUT:
        RETVAL

unsigned
get_bpp(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetBPP(self->dib);
    OUTPUT:
        RETVAL

unsigned
get_width(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetWidth(self->dib);
    OUTPUT:
        RETVAL

unsigned
get_height(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetHeight(self->dib);
    OUTPUT:
        RETVAL

unsigned
get_dots_per_meter_x(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetDotsPerMeterX(self->dib);
    OUTPUT:
        RETVAL

void
set_dots_per_meter_x(PDL::IO::Image self, unsigned res)
    CODE:
        FreeImage_SetDotsPerMeterX(self->dib, res);

unsigned
get_dots_per_meter_y(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetDotsPerMeterY(self->dib);
    OUTPUT:
        RETVAL

void
set_dots_per_meter_y(PDL::IO::Image self, unsigned res)
    CODE:
        FreeImage_SetDotsPerMeterY(self->dib, res);

const char*
get_color_type(PDL::IO::Image self)
    CODE:
        RETVAL = _fic2str(FreeImage_GetColorType(self->dib));
    OUTPUT:
        RETVAL

int
is_transparent(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_IsTransparent(self->dib);
    OUTPUT:
        RETVAL

int
get_transparent_index(PDL::IO::Image self)
    CODE:
        RETVAL = FreeImage_GetTransparentIndex(self->dib);
    OUTPUT:
        RETVAL

void
set_transparent_index(PDL::IO::Image self, int index)
    CODE:
        FreeImage_SetTransparentIndex(self->dib, index);

void
flip_horizontal(PDL::IO::Image self)
    CODE:
        FreeImage_FlipHorizontal(self->dib);

void
flip_vertical(PDL::IO::Image self)
    CODE:
        FreeImage_FlipVertical(self->dib);

void
convert_image_type(PDL::IO::Image self, SV * dst_image_type, int scale_linear=1)
    CODE:
    {
        FREE_IMAGE_TYPE fit = _sv2fit(dst_image_type);
        if (fit == FIT_UNKNOWN) {
          warn("invalid dst_image_type");
        }
        else {
          FIBITMAP *newdib = FreeImage_ConvertToType(self->dib, fit, scale_linear);
          if (newdib) {
            if (self->dib) FreeImage_Unload(self->dib);
            self->dib = newdib;
          }
          else {
            warn("FreeImage_ConvertToType (fit=%d) failed", fit);
          }
        }
    }

void
adjust_colors(PDL::IO::Image self, double brightness=0, double contrast=0, double gamma=0, int invert=0)
    CODE:
        FreeImage_AdjustColors(self->dib, brightness, contrast, gamma, invert);

void
tone_mapping(PDL::IO::Image self, int tmo, double p1=0, double p2=0)
    CODE:
    {
        if (tmo == FITMO_DRAGO03 || tmo == FITMO_REINHARD05 || tmo == FITMO_FATTAL02) {
          FIBITMAP *newdib = FreeImage_ToneMapping(self->dib, tmo, p1, p2);
          if (newdib) {
            if (self->dib) FreeImage_Unload(self->dib);
            self->dib = newdib;
          }
          else {
            warn("FreeImage_ToneMapping (tmp=%d) failed", tmo);
          }
        }
        else {
          warn("invalid tone mapping operator");
        }
    }

void
rotate(PDL::IO::Image self, double angle)
    CODE:
    {
        FIBITMAP *newdib = FreeImage_Rotate(self->dib, angle, NULL); /* XXX maybe handle bgcolor */
        if (newdib) {
          if (self->dib) FreeImage_Unload(self->dib);
          self->dib = newdib;
        }
        else {
          warn("FreeImage_Rotate failed");
        }
    }

void
rescale(PDL::IO::Image self, int dst_width=0, int dst_height=0, int filter=FILTER_CATMULLROM)
    CODE:
    {
        if (dst_height<=0 && dst_width>0) {
          double ratio = (double)dst_width / (double)FreeImage_GetWidth(self->dib);
          dst_height   = (int)floor(0.5 + ratio * (double)FreeImage_GetHeight(self->dib));
        }
        else if (dst_width<=0 && dst_height>0) {
          double ratio = (double)dst_height / (double)FreeImage_GetHeight(self->dib);
          dst_width    = (int)floor(0.5 + ratio * (double)FreeImage_GetWidth(self->dib));
        }
        if (dst_height>0 && dst_width>0) {
          FIBITMAP *newdib = FreeImage_Rescale(self->dib, dst_width, dst_height, filter);
          if (newdib) {
            if (self->dib) FreeImage_Unload(self->dib);
            self->dib = newdib;
          }
          else {
            warn("FreeImage_Rescale failed");
          }
        }
    }

void
rescale_pct(PDL::IO::Image self, double dst_width_pct=0, double dst_height_pct=0, int filter=FILTER_CATMULLROM)
    CODE:
    {
        int dst_height = (int)floor(0.5 + (double)FreeImage_GetHeight(self->dib) * dst_height_pct / 100.0);
        int dst_width  = (int)floor(0.5 + (double)FreeImage_GetWidth(self->dib)  * dst_width_pct  / 100.0);
        
        if (dst_height<=0 && dst_width>0) {
          double ratio = (double)dst_width / (double)FreeImage_GetWidth(self->dib);
          dst_height   = (int)floor(0.5 + ratio * (double)FreeImage_GetHeight(self->dib));
        }
        else if (dst_width<=0 && dst_height>0) {
          double ratio = (double)dst_height / (double)FreeImage_GetHeight(self->dib);
          dst_width    = (int)floor(0.5 + ratio * (double)FreeImage_GetWidth(self->dib));
        }
        if (dst_height>0 && dst_width>0) {
          FIBITMAP *newdib = FreeImage_Rescale(self->dib, dst_width, dst_height, filter);
          if (newdib) {
            if (self->dib) FreeImage_Unload(self->dib);
            self->dib = newdib;
          }
          else {
            warn("FreeImage_Rescale failed");
          }
        }
    }

void
save(PDL::IO::Image self, const char *filename, SV * f=NULL, int flags=0);
    CODE:
    {
        if (self->dib) {
          FREE_IMAGE_FORMAT fif = _sv2fif(f);
          if (fif == FIF_UNKNOWN) fif = FreeImage_GetFIFFromFilename(filename);
          if (fif == FIF_UNKNOWN) croak("FAIL: unspecified format");
          FreeImage_Save(fif, self->dib, filename, flags);
        }
    }

pdl*
palette_to_pdl(PDL::IO::Image self)
    CODE:
    {
        pdl *pal_pdl = NULL;
        PDL_Indx dims[] = {0, 0, 0};
        int cu = FreeImage_GetColorsUsed(self->dib);
        if (cu==0) XSRETURN_UNDEF;

        PDL_Byte *pdata;
        int i;
        dims[0] = 3;
        dims[1] = cu;
        pal_pdl = PDL->pdlnew();
        pal_pdl->datatype = PDL_B;
        PDL->setdims (pal_pdl, dims, 2);
        PDL->allocdata (pal_pdl);
        pdata = (PDL_Byte *) pal_pdl->data;
        RGBQUAD *pal = FreeImage_GetPalette(self->dib);
        for (i = 0; i < cu; i++) {
          pdata[i*3]     = (PDL_Byte) pal[i].rgbRed;
          pdata[i*3 + 1] = (PDL_Byte) pal[i].rgbGreen;
          pdata[i*3 + 2] = (PDL_Byte) pal[i].rgbBlue;
        }
        RETVAL = pal_pdl;
    }
    OUTPUT:
        RETVAL

pdl*
pixels_to_pdl(PDL::IO::Image self, long x1=0, long x2=0, long y1=0, long y2=0)
    CODE:
    {
        pdl *bmp_pdl = NULL;
        PDL_Indx dims[] = {0, 0, 0};
        PDL_Indx x, y, wxh;
        unsigned long w, h, wp, hp;
        int bpp, it;

        w   = FreeImage_GetWidth(self->dib);
        h   = FreeImage_GetHeight(self->dib);
        bpp = FreeImage_GetBPP(self->dib);
        it  = FreeImage_GetImageType(self->dib);
        wp  = w;
        hp  = h;

        if (!FreeImage_HasPixels(self->dib) || w == 0 || h == 0) {
          warn("FAIL: no pixels");
          XSRETURN_UNDEF;
        }

        /* handle negative boundaries */
        if (x1 < 0)  x1 = w - 1 + x1;
        if (y1 < 0)  y1 = h - 1 + y1;
        if (x2 <= 0) x2 = w - 1 + x2;
        if (y2 <= 0) y2 = h - 1 + y2;
        /* handle region selection */
        wp = (x2 - x1 + 1);
        hp = (y2 - y1 + 1);
        wxh = wp * hp;
        
        if (x1>x2 || y1>y2 || x1<0 || y1<0 || x2<0 || y2<0 || wp>w || hp>h) {
          warn("FAIL: invalid region");
          XSRETURN_UNDEF;
        }

        switch (it) {
          case FIT_BITMAP:      /* Standard image: 1-, 4-, 8-, 16-, 24-, 32-bit */
            if (bpp==32) {
              PDL_Byte *pdata;
              dims[0] = wp;
              dims[1] = hp;
              dims[2] = 4;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_B;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Byte *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                RGBQUAD *bits = (RGBQUAD*) FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x]         = (PDL_Byte) bits[x+x1].rgbRed;
                  pdata[y*wp + x + wxh]   = (PDL_Byte) bits[x+x1].rgbGreen;
                  pdata[y*wp + x + 2*wxh] = (PDL_Byte) bits[x+x1].rgbBlue;
                  pdata[y*wp + x + 3*wxh] = (PDL_Byte) bits[x+x1].rgbReserved;
                }
              }
            }
            else if (bpp==24) {
              PDL_Byte *pdata;
              dims[0] = wp;
              dims[1] = hp;
              dims[2] = 3;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_B;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Byte *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                RGBTRIPLE *bits = (RGBTRIPLE*) FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x]         = (PDL_Byte) bits[x+x1].rgbtRed;
                  pdata[y*wp + x + wxh]   = (PDL_Byte) bits[x+x1].rgbtGreen;
                  pdata[y*wp + x + 2*wxh] = (PDL_Byte) bits[x+x1].rgbtBlue;
                }
              }
            }
            else if (bpp==16) {
              unsigned red_mask, green_mask, blue_mask;
              PDL_Byte *pdata;
              dims[0] = wp;
              dims[1] = hp;
              dims[2] = 3;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_B;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Byte *) bmp_pdl->data;
              red_mask   = FreeImage_GetRedMask(self->dib);
              green_mask = FreeImage_GetGreenMask(self->dib);
              blue_mask  = FreeImage_GetBlueMask(self->dib);
              if ( (red_mask == FI16_565_RED_MASK) && (green_mask == FI16_565_GREEN_MASK) && (blue_mask == FI16_565_BLUE_MASK) ) {
                for(y = 0; y < hp; y++) {
                  WORD *bits = (WORD*)FreeImage_GetScanLine(self->dib, h-y-1-y1);
                  for(x = 0; x < wp; x++) {
                    PDL_Byte r5 = (PDL_Byte)((bits[x+x1] & FI16_565_RED_MASK)   >> FI16_565_RED_SHIFT)  ;
                    PDL_Byte g6 = (PDL_Byte)((bits[x+x1] & FI16_565_GREEN_MASK) >> FI16_565_GREEN_SHIFT);
                    PDL_Byte b5 = (PDL_Byte)((bits[x+x1] & FI16_565_BLUE_MASK)  >> FI16_565_BLUE_SHIFT) ;
                    /* http://stackoverflow.com/questions/2442576/how-does-one-convert-16-bit-rgb565-to-24-bit-rgb888 */
                    pdata[y*wp + x]         = (r5 << 3) | (r5 >> 2);
                    pdata[y*wp + x + wxh]   = (g6 << 2) | (g6 >> 4);
                    pdata[y*wp + x + 2*wxh] = (b5 << 3) | (b5 >> 2);
                  }
                }
              }
              else {
                for(y = 0; y < hp; y++) {
                  WORD *bits = (WORD*)FreeImage_GetScanLine(self->dib, h-y-1-y1);
                  for(x = 0; x < wp; x++) {
                    PDL_Byte r5 = (PDL_Byte)((bits[x+x1] & FI16_555_RED_MASK)   >> FI16_555_RED_SHIFT)  ;
                    PDL_Byte g5 = (PDL_Byte)((bits[x+x1] & FI16_555_GREEN_MASK) >> FI16_555_GREEN_SHIFT);
                    PDL_Byte b5 = (PDL_Byte)((bits[x+x1] & FI16_555_BLUE_MASK)  >> FI16_555_BLUE_SHIFT) ;
                    pdata[y*wp + x]         = (r5 << 3) | (r5 >> 2);
                    pdata[y*wp + x + wxh]   = (g5 << 3) | (g5 >> 2);
                    pdata[y*wp + x + 2*wxh] = (b5 << 3) | (b5 >> 2);
                  }
                }
              }
            }
            else if (bpp==8) {
              PDL_Byte *pdata;
              dims[0] = wp;
              dims[1] = hp;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_B;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Byte *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                BYTE *bits = FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x] = (PDL_Byte) bits[x+x1];
                }
              }
            }
            else if (bpp==4) {
              PDL_Byte *pdata;
              dims[0] = wp;
              dims[1] = hp;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_B;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Byte *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                BYTE *bits = FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x] = (PDL_Byte) ((bits[(x+x1)/2] >> 4*(1-(x+x1)%2)) & 0x0F);
                }
              }
            }
            else if (bpp==1) {
              PDL_Byte *pdata;
              dims[0] = wp;
              dims[1] = hp;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_B;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Byte *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                BYTE *bits = FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x] = (PDL_Byte) ((bits[(x+x1)/8] >> (7-(x+x1)%8)) & 0x01);
                }
              }
            }
            else {
              warn("FAIL: unknown bits per pixel '%d'", bpp);
            }
            break;
          case FIT_UINT16:      /* Array of unsigned short: unsigned 16-bit */
            {
              PDL_Ushort *pdata;
              dims[0] = wp;
              dims[1] = hp;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_US;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Ushort *) bmp_pdl->data;

              for(y = 0; y < hp; y++) {
                PDL_Ushort *bits = (PDL_Ushort*)FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x] = bits[x+x1];
                }
              }
            }
            break;
          case FIT_INT16:       /* Array of short: signed 16-bit */
            {
              PDL_Short *pdata;
              dims[0] = wp;
              dims[1] = hp;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_S;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Short *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                PDL_Short *bits = (PDL_Short*)FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x] = bits[x+x1];
                }
              }
            }
            break;
          case FIT_UINT32:      /* Array of unsigned long: unsigned 32-bit */
            { /* XXX-TODO hack: using INT64 for UINT32 */
              PDL_LongLong *pdata;
              dims[0] = wp;
              dims[1] = hp;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_LL;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_LongLong *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                DWORD *bits = (DWORD*)FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x] = (PDL_LongLong)bits[x+x1];
                }
              }
            }
            break;
          case FIT_INT32:       /* Array of long: signed 32-bit */
            {
              PDL_Long *pdata;
              dims[0] = wp;
              dims[1] = hp;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_L;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Long *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                PDL_Long *bits = (PDL_Long*)FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x] = bits[x+x1];
                }
              }
            }
            break;
          case FIT_FLOAT:       /* Array of float: 32-bit IEEE floating point */
            {
              PDL_Float *pdata;
              dims[0] = wp;
              dims[1] = hp;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_F;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Float *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                PDL_Float *bits = (PDL_Float*)FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x] = bits[x+x1];
                }
              }
            }
            break;
          case FIT_DOUBLE:      /* Array of double: 64-bit IEEE floating point */
            {
              PDL_Double *pdata;
              dims[0] = wp;
              dims[1] = hp;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_D;
              PDL->setdims (bmp_pdl, dims, 2);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Double *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                PDL_Double *bits = (PDL_Double*)FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x] = bits[x+x1];
                }
              }
            }
            break;
          case FIT_COMPLEX:     /* Array of FICOMPLEX: 2 x 64-bit IEEE floating point */
            warn("FAIL: FIT_COMPLEX not supported");
            /* for(y = 0; y < hp; y++) {
             *   FICOMPLEX *bits = (FICOMPLEX *)FreeImage_GetScanLine(self->dib, h-y-1-y1);
             *   for(x = 0; x < wp; x++) {
             *     pdata[y*wp + x] = (PDL_Double) bits[x+x1].r;
             *     pdata[y*wp + x] = (PDL_Double) bits[x+x1].i;
             *   }
             * }
             */
            break;
          case FIT_RGB16:       /* 48-bit RGB image: 3 x 16-bit */
            {
              PDL_Ushort *pdata;
              dims[0] = wp;
              dims[1] = hp;
              dims[2] = 3;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_US;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Ushort *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                FIRGB16 *bits = (FIRGB16*) FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x]         = (PDL_Ushort) bits[x+x1].red;
                  pdata[y*wp + x + wxh]   = (PDL_Ushort) bits[x+x1].green;
                  pdata[y*wp + x + 2*wxh] = (PDL_Ushort) bits[x+x1].blue;
                }
              }
            }
            break;
          case FIT_RGBA16:      /* 64-bit RGBA image: 4 x 16-bit */
            {
              PDL_Ushort *pdata;
              dims[0] = wp;
              dims[1] = hp;
              dims[2] = 4;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_US;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Ushort *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                FIRGBA16 *bits = (FIRGBA16*) FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x]         = (PDL_Ushort) bits[x+x1].red;
                  pdata[y*wp + x + wxh]   = (PDL_Ushort) bits[x+x1].green;
                  pdata[y*wp + x + 2*wxh] = (PDL_Ushort) bits[x+x1].blue;
                  pdata[y*wp + x + 3*wxh] = (PDL_Ushort) bits[x+x1].alpha;
                }
              }
            }
            break;
          case FIT_RGBF:        /* 96-bit RGB float image: 3 x 32-bit IEEE floating point */
            {
              PDL_Float *pdata;
              dims[0] = wp;
              dims[1] = hp;
              dims[2] = 3;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_F;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Float *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                FIRGBF *bits = (FIRGBF*) FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x]         = (PDL_Float) bits[x+x1].red;
                  pdata[y*wp + x + wxh]   = (PDL_Float) bits[x+x1].green;
                  pdata[y*wp + x + 2*wxh] = (PDL_Float) bits[x+x1].blue;
                }
              }
            }
            break;
          case FIT_RGBAF:       /* 128-bit RGBA float image: 4 x 32-bit IEEE floating point */
            {
              PDL_Float *pdata;
              dims[0] = wp;
              dims[1] = hp;
              dims[2] = 4;
              bmp_pdl = PDL->pdlnew();
              bmp_pdl->datatype = PDL_F;
              PDL->setdims (bmp_pdl, dims, 3);
              PDL->allocdata (bmp_pdl);
              pdata = (PDL_Float *) bmp_pdl->data;
              for(y = 0; y < hp; y++) {
                FIRGBAF *bits = (FIRGBAF*) FreeImage_GetScanLine(self->dib, h-y-1-y1);
                for(x = 0; x < wp; x++) {
                  pdata[y*wp + x]         = (PDL_Float) bits[x+x1].red;
                  pdata[y*wp + x + wxh]   = (PDL_Float) bits[x+x1].green;
                  pdata[y*wp + x + 2*wxh] = (PDL_Float) bits[x+x1].blue;
                  pdata[y*wp + x + 3*wxh] = (PDL_Float) bits[x+x1].alpha;
                }
              }
            }
            break;
          default:
            warn("FAIL: unknown image type '%d'", it);
            break;
        }

        if (bmp_pdl == NULL) XSRETURN_UNDEF;
        RETVAL = bmp_pdl;
    }
    OUTPUT:
        RETVAL

void
DESTROY(self)
        PDL::IO::Image self
    CODE:
        if (self->dib != NULL) FreeImage_Unload(self->dib);
        Safefree(self);

ENDXS

############################################################### PM part
pp_bless('PDL');
pp_add_exported('wimage');
pp_add_exported('rimage');
pp_addpm( <<'ENDPM' );
use strict;
use warnings;
use Carp;

###XXX FIXME
#sub import {
#  my $package = shift;
#  {
#    no strict 'refs';
#    *{'PDL::wimage'} = \&PDL::IO::Image::wimage;### if grep { /^(:all|wimage)$/ } @_;
#  }
#  __PACKAGE__->export_to_level(1, $package, @_) if @_;
#}

{
  no strict 'refs';
  *{'PDL::wimage'} = \&PDL::IO::Image::wimage;### if grep { /^(:all|wimage)$/ } @_;
}

sub _val2list {
  return @{$_[0]} if ref $_[0] eq 'ARRAY';
  return $_[0];
};

sub rimage {
  my $options = ref $_[-1] eq 'HASH' ? pop : {};
  my $filename = shift;
  $options->{format} = "AUTO" unless defined $options->{format};
  $options->{format_flag} = 0 unless defined $options->{format_flag};
  $options->{page} = 0        unless defined $options->{page};
  my $pimage = PDL::IO::Image->new_from_file($filename, $options->{format}, $options->{format_flag}, $options->{page});

  if (my $flip = $options->{flip}) {
    $pimage->flip_horizontal if $flip =~ /H/;
    $pimage->flip_vertical   if $flip =~ /V/;
  }
  if (defined $options->{convert_image_type}) {
    $pimage->convert_image_type(_val2list($options->{convert_image_type}));
  }

  $options->{region} = [] unless ref $options->{region} eq 'ARRAY';
  if ($options->{palette}) {
    return ($pimage->pixels_to_pdl(@{$options->{region}}), $pimage->palette_to_pdl);
  }
  return $pimage->pixels_to_pdl(@{$options->{region}});
}

sub wimage {
  my $options = ref $_[-1] eq 'HASH' ? pop : {};
  my ($pixels, $filename) = @_;
  my $palette = $options->{palette} if ref $options->{palette} eq 'PDL';
  my $pimage = defined $palette ?
               PDL::IO::Image->new_from_pdl($pixels, $palette) :
               PDL::IO::Image->new_from_pdl($pixels);

  if (my $flip = $options->{flip}) {
    $pimage->flip_horizontal if $flip =~ /H/;
    $pimage->flip_vertical   if $flip =~ /V/;
  }
  if (defined $options->{rotate}) {
    $pimage->rotate(_val2list($options->{rotate}));
  }
  if (defined $options->{rescale}) {
    $pimage->rescale(_val2list($options->{rescale}));
  }
  if (defined $options->{rescale_pct}) {
    $pimage->rescale_pct(_val2list($options->{rescale_pct}));
  }
  if (defined $options->{convert_image_type}) {
    $pimage->convert_image_typeconvert_image_type(_val2list($options->{convert_image_type}));
  }

  $options->{format} = "AUTO" unless defined $options->{format};
  $options->{format_flag} = 0 unless defined $options->{format_flag};
  $pimage->save($filename, $options->{format}, $options->{format_flag});
  return $pixels;
}

ENDPM

############################################################### Constants part
use ExtUtils::Constant qw (WriteConstants);

my @C = (
    ### load/save flags
    { type=>'IV', name=>'BMP_SAVE_RLE' },
    { type=>'IV', name=>'EXR_FLOAT' },
    { type=>'IV', name=>'EXR_NONE' },
    { type=>'IV', name=>'EXR_ZIP' },
    { type=>'IV', name=>'EXR_PIZ' },
    { type=>'IV', name=>'EXR_PXR24' },
    { type=>'IV', name=>'EXR_B44' },
    { type=>'IV', name=>'EXR_LC' },
    { type=>'IV', name=>'GIF_LOAD256' },
    { type=>'IV', name=>'GIF_PLAYBACK' },
    { type=>'IV', name=>'ICO_MAKEALPHA' },
    { type=>'IV', name=>'JPEG_FAST' },
    { type=>'IV', name=>'JPEG_ACCURATE' },
    { type=>'IV', name=>'JPEG_CMYK' },
    { type=>'IV', name=>'JPEG_EXIFROTATE' },
    { type=>'IV', name=>'JPEG_GREYSCALE' },
    { type=>'IV', name=>'JPEG_QUALITYSUPERB' },
    { type=>'IV', name=>'JPEG_QUALITYGOOD' },
    { type=>'IV', name=>'JPEG_QUALITYNORMAL' },
    { type=>'IV', name=>'JPEG_QUALITYAVERAGE' },
    { type=>'IV', name=>'JPEG_QUALITYBAD' },
    { type=>'IV', name=>'JPEG_PROGRESSIVE' },
    { type=>'IV', name=>'JPEG_SUBSAMPLING_411' },
    { type=>'IV', name=>'JPEG_SUBSAMPLING_420' },
    { type=>'IV', name=>'JPEG_SUBSAMPLING_422' },
    { type=>'IV', name=>'JPEG_SUBSAMPLING_444' },
    { type=>'IV', name=>'JPEG_OPTIMIZE' },
    { type=>'IV', name=>'JPEG_BASELINE' },
    { type=>'IV', name=>'PCD_BASE' },
    { type=>'IV', name=>'PCD_BASEDIV4' },
    { type=>'IV', name=>'PCD_BASEDIV16' },
    { type=>'IV', name=>'PNG_IGNOREGAMMA' },
    { type=>'IV', name=>'PNG_Z_BEST_SPEED' },
    { type=>'IV', name=>'PNG_Z_DEFAULT_COMPRESSION' },
    { type=>'IV', name=>'PNG_Z_BEST_COMPRESSION' },
    { type=>'IV', name=>'PNG_Z_NO_COMPRESSION' },
    { type=>'IV', name=>'PNG_INTERLACED' },
    { type=>'IV', name=>'PNM_SAVE_ASCII' },
    { type=>'IV', name=>'PSD_CMYK' },
    { type=>'IV', name=>'PSD_LAB' },
    { type=>'IV', name=>'RAW_PREVIEW' },
    { type=>'IV', name=>'RAW_DISPLAY' },
    { type=>'IV', name=>'RAW_HALFSIZE' },
    { type=>'IV', name=>'TARGA_LOAD_RGB888' },
    { type=>'IV', name=>'TARGA_SAVE_RLE' },
    { type=>'IV', name=>'TIFF_CMYK' },
    { type=>'IV', name=>'TIFF_PACKBITS' },
    { type=>'IV', name=>'TIFF_DEFLATE' },
    { type=>'IV', name=>'TIFF_ADOBE_DEFLATE' },
    { type=>'IV', name=>'TIFF_NONE' },
    { type=>'IV', name=>'TIFF_CCITTFAX3' },
    { type=>'IV', name=>'TIFF_CCITTFAX4' },
    { type=>'IV', name=>'TIFF_LZW' },
    { type=>'IV', name=>'TIFF_JPEG' },
    { type=>'IV', name=>'TIFF_LOGLUV' },
    { type=>'IV', name=>'WEBP_LOSSLESS' },
    { type=>'IV', name=>'JXR_LOSSLESS' },
    { type=>'IV', name=>'JXR_PROGRESSIVE' },
);

WriteConstants(NAME => 'PDL::IO::Image', NAMES => [ map { { macro=>1,type=>$_->{type},name=>$_->{name}} } @C ]);
pp_addpm("### Constants");
### pp_add_exported(map {$_->{name}} @C);
pp_addpm("sub $_->{name}() { (constant('$_->{name}'))[1] }") for (@C);

############################################################### POD part
pp_addpm(<<'ENDPOD');
=head1 NAME

PDL::IO::Image - Load/save bitmap from/to PDL (via FreeImage library)

=head1 SYNOPSIS

XXX some code examples

=head1 DESCRIPTION

XXX

=head2 Supported image formats

XXX png, gif, tif, ...

=head2 Supported image types

XXX BITMAP, RGB, RGBA, FLOAT, DOUBLE, ...

=head1 FUNCTIONS

=head2 rimage

 my $pixels_pdl = rimage($filename);
 #or
 my $pixels_pdl = rimage($filename, \%options);
 #or
 my ($pixels_pdl, $palette_pdl) = rimage($filename, { palette=>1 });

=head2 wimage

 $pixels_pdl->wimage($filename);
 #or
 $pixels_pdl->wimage($filename, \%options);
 
 wimage($pixels_pdl, $filename);
 #or
 wimage($pixels_pdl, $filename, \%options);

=head1 METHODS

=head2 new_from_file

 my $pimage = IO::PDL::Image->new_from_file($filename);
 #or
 my $pimage = IO::PDL::Image->new_from_file($filename, $filetype);
 #or
 my $pimage = IO::PDL::Image->new_from_file($filename, $filetype, $flags);
 #or
 my $pimage = IO::PDL::Image->new_from_file($filename, $filetype, $flags, $page);

=head2 new_from_pdl

 my $pimage = IO::PDL::Image->new_from_pdl($pixels_pdl);
 #or
 my $pimage = IO::PDL::Image->new_from_pdl($pixels_pdl, $palette_pdl);

=head2 pixels_to_pdl

 my $pixels_pdl = $pimage->pixels_to_pdl;
 #or
 my $pixels_pdl = $pimage->pixels_to_pdl($x1, $x2, $y1, $y2);

=head2 palette_to_pdl

 my $palette_pdl = $pimage->palette_to_pdl;

=head2 save

 $pimage->save($filename, $format, $flags);
 #or
 $pimage->save($filename, $format);
 #or
 $pimage->save($filename);

=head2 get_image_type

 my $imtype = $pimage->get_image_type;

=head2 get_colors_used

 my $colors = $pimage->get_colors_used;

=head2 get_bpp

 my $bpp = $pimage->get_bpp;

=head2 get_width

 my $w = $pimage->get_width;

=head2 get_height

 my $h = $pimage->get_height;

=head2 get_dots_per_meter_x

 my $dpmx = $pimage->get_dots_per_meter_x;

=head2 set_dots_per_meter_x

 $pimage->set_dots_per_meter_x($res);

=head2 get_dots_per_meter_y

 my $dpmy = $pimage->get_dots_per_meter_y;

=head2 set_dots_per_meter_y

 $pimage->set_dots_per_meter_y($res);

=head2 get_color_type

 my $coltype = $pimage->get_color_type;

=head2 is_transparent

 my $bool = $pimage->is_transparent;

=head2 get_transparent_index

 my $idx = $pimage->get_transparent_index;

=head2 set_transparent_index

 $pimage->set_transparent_index($index);

=head2 flip_horizontal

 $pimage->flip_horizontal;

=head2 flip_vertical

 $pimage->flip_vertical;

=head2 rotate

 $pimage->rotate($angle);

=head2 rescale

 $pimage->rescale($dst_width, $dst_height, $filter);
 #or
 $pimage->rescale($dst_width, 0);
 #or
 $pimage->rescale(0, $dst_height);

=head2 rescale_pct

 $pimage->rescale($dst_width_pct, $dst_height_pct, $filter);
 #or
 $pimage->rescale($dst_width_pct, 0);
 #or
 $pimage->rescale(0, $dst_height_pct);

=head2 convert_image_type

 $pimage->convert_image_type($dst_image_type, $scale_linear);
 #or
 $pimage->convert_image_type($dst_image_type);

=head2 adjust_colors

 $pimage->adjust_colors($brightness, $contrast, $gamma, $invert);

=head2 tone_mapping

 $pimage->tone_mapping($tone_mapping_operator, $param1, $param2);
 # $tone_mapping_operator
 #    0 = Adaptive logarithmic mapping (F. Drago, 2003)
 #    1 = Dynamic range reduction inspired by photoreceptor physiology (E. Reinhard, 2005)
 #    2 = Gradient domain high dynamic range compression (R. Fattal, 2002)

=head2 free_image_version

 my $v = PDL::IO::Image->free_image_version();

=head2 format_list

 my @f = PDL::IO::Image->format_list();

=head2 format_extension_list

 my $ext = PDL::IO::Image->format_extension_list($format);

=head2 format_mime_type

 my $mtype = PDL::IO::Image->format_mime_type($format);

=head2 format_description

 my $desc = PDL::IO::Image->format_description($format);

=head2 format_can_read

 my $bool = PDL::IO::Image->format_can_read($format);

=head2 format_can_write

 my $bool = PDL::IO::Image->format_can_write($format);

=head2 format_can_export_type

 my $bool = PDL::IO::Image->format_can_export_type($format, $imgtype);

=head2 format_can_export_bpp

 my $bool = PDL::IO::Image->format_can_export_bpp($format, $bpp);

=head2 format_from_mime

 my $format = PDL::IO::Image->format_from_mime($mime_type);

=head2 format_from_file

 my $format = PDL::IO::Image->format_from_file($filename);

=cut
ENDPOD

pp_done();